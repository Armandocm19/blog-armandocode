---
title: 'No cometas estos errores en tu código de JavaScript'
date: '2023-01-13'
imgTitle: 'javascript.png'
description: 'Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en JavaScript. Aquí te las enseño.✍'
---

Existen ciertos errores que no debemos cometer si estamos aprendiendo a programar en **JavaScript**.

Podríamos decir que no son errores exactamente, si no estándares que se tienen a la hora de programar
en este lenguaje.

Esto con el fin de que nuestro código sea mucho más legible, y se pueda entender mejor. Y en ocasiones
pueden funcionar para mejorar nuestro rendimiento en la página.

Recordemos que muchas veces no somo los **unicos** que tenemos que entender nuestro código. Ya que si trabajas en una empresa,
o bien buscas empleo, es importante tener en cuenta estos factores para demostrar que eres ordenado con tu código, y los demás
puedan entenderlo mucho mejor. 👨‍💻

## 1° Caso: Condiciones redondantes 


No debemos de tener condiciones las cuales si dan **true**, devuelve **true**.

Como se muestra en el siguiente caso. 👇

❌
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    if( num1 > num2 ){
        return true;
    }else {
        return false;
    }
}
```

O el mismo caso, pero usando ternarias.

❌
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2 
    ? true 
    : false;
}
```

Por lo que, en un caso como este, es recomendable devolver directamente la condición.

✅
```js
const num1 = 10;
const num2 = 5;
const validacionEntreNumeros = ( num1, num2 ) => {
    return num1 > num2;
}
```

Mucho más limpio, **verdad?**

## 2° Caso: No utilices `filter`, ni un `bucle` para hacer esto. 

Si tenemos el siguiente array de objetos. 👇

```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
```

Y queremos buscar si alguna de las personas de los objetos es mayor de edad. Donde en caso de que sí haya, devolverá **true**

Posiblemente te verías tentado a usar el método `filter`. 

De esta manera. 👇

❌
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
Boolean(personas.filter(persona => {
    return persona.age >= 18;
})[0])
```

Esta manera es **horrible**, ya que debemos acceder a la primera posición, y además de eso tenemos que convertir todo en un Booleano.

Otra forma **errónea** es utilizando algún bucle, como lo sería un `forEach`, `while`, o `for`. 

Como el siguiente ejemplo. 👇


❌
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
let found = false;
personas.forEach(persona => {
    if( !found ) {
        found = persona.age >= 18;
    }
})
```

Esto no es correcto, ya que lo que hará es recorrer todos los objetos **idenpendientemente** de si lo a encontrado ya.🤦‍♂️

Por lo que, en su lugar, debemos utilizar el método `some`.

De esta manera. 👇

✅
```js
const personas = [
    { name: 'Karla', age: 14 },
    { name: 'Jack', age: 17 },
    { name: 'Jonathan', age: 15 }
]
personas.some((persona) => {
    return persona.age >= 18;
})
```

Esta es la mejora forma de hacerlo, ya que el método `some` devolverá **true** al primer elemento que cumpla la condición.👌